<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BL1P - Agent IA Interdimensionnel Ultime</title>
  <style>
    :root {
      --neon-cyan: #00ffe0;
      --neon-pink: #ff00aa;
      --matrix-green: #00ff44;
      --void-black: #0a0a0a;
      --error-red: #ff0033;
      --quantum-purple: #bb00ff;
    }
    
    @keyframes glitch {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(2px, -2px); }
      60% { transform: translate(3px, 1px); }
      80% { transform: translate(-1px, -3px); }
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--neon-cyan); }
      50% { transform: scale(1.05); box-shadow: 0 0 40px var(--neon-pink); }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes hallucination {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    @keyframes energy-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; text-shadow: 0 0 10px var(--quantum-purple); }
    }
    
    body {
      background-color: var(--void-black);
      color: var(--neon-cyan);
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 2rem;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }
    
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 224, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 170, 0.05) 0%, transparent 20%);
      pointer-events: none;
      z-index: -1;
    }
    
    h1 {
      font-family: monospace;
      text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-pink);
      animation: glitch 5s infinite alternate;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    
    #blip-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    }
    
    #blip-avatar {
      width: 150px;
      height: 150px;
      background: radial-gradient(circle, var(--neon-cyan) 0%, var(--void-black) 70%);
      border-radius: 50%;
      margin: 1rem 0;
      position: relative;
      animation: pulse 4s ease-in-out infinite;
    }
    
    #blip-avatar::before {
      content: "BL1P";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      font-weight: bold;
      color: var(--void-black);
      mix-blend-mode: lighten;
    }
    
    #chat-interface {
      width: 100%;
      margin-top: 2rem;
      border: 1px solid var(--neon-cyan);
      padding: 1rem;
      background-color: rgba(10, 10, 10, 0.7);
      box-shadow: 0 0 15px var(--neon-cyan);
    }
    
    #chat-log {
      height: 300px;
      overflow-y: auto;
      margin-bottom: 1rem;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.5);
      border: 1px dashed var(--neon-cyan);
    }
    
    .message {
      margin-bottom: 1rem;
      padding: 0.5rem;
      border-left: 3px solid var(--neon-cyan);
      animation: fadeIn 0.5s;
    }
    
    .user-message {
      color: var(--neon-pink);
      border-left-color: var(--neon-pink);
    }
    
    .blip-message {
      color: var(--neon-cyan);
    }
    
    .binary {
      font-family: monospace;
      color: var(--matrix-green);
    }
    
    #user-input {
      width: 100%;
      padding: 0.8rem;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-cyan);
      color: var(--neon-cyan);
      font-family: 'Courier New', monospace;
      margin-bottom: 1rem;
    }
    
    #send-btn {
      padding: 0.8rem 2rem;
      background-color: var(--void-black);
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      cursor: pointer;
      font-family: monospace;
      font-size: 1rem;
      transition: all 0.3s;
    }
    
    #send-btn:hover {
      background-color: var(--neon-cyan);
      color: var(--void-black);
      box-shadow: 0 0 15px var(--neon-cyan);
    }
    
    .typing-indicator {
      color: var(--neon-cyan);
      font-style: italic;
      opacity: 0.7;
    }
    
    #special-actions {
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .action-btn {
      padding: 0.5rem 1rem;
      background-color: transparent;
      border: 1px solid var(--neon-pink);
      color: var(--neon-pink);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .action-btn:hover {
      background-color: var(--neon-pink);
      color: var(--void-black);
    }
    
    #image-output {
      margin-top: 2rem;
      max-width: 100%;
      border: 1px solid var(--neon-cyan);
      display: none;
    }
    
    .mirror-effect {
      transform: scaleX(-1);
      filter: hue-rotate(180deg);
    }
    
    .upload-container {
      margin: 1rem 0;
      position: relative;
    }
    
    #file-upload {
      display: none;
    }
    
    .upload-label {
      display: inline-block;
      padding: 0.8rem 1.5rem;
      background-color: var(--void-black);
      border: 2px dashed var(--neon-pink);
      color: var(--neon-pink);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-label:hover {
      background-color: rgba(255, 0, 170, 0.1);
    }
    
    #upload-preview {
      max-width: 100%;
      max-height: 200px;
      margin-top: 1rem;
      display: none;
      border: 1px solid var(--neon-cyan);
    }
    
    .command {
      color: var(--matrix-green);
      font-weight: bold;
    }
    
    .hallucination-mode {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
    }
    
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 2rem;
      padding: 1rem;
      border-top: 1px solid var(--neon-cyan);
    }
    
    .gallery-item {
      position: relative;
      cursor: pointer;
      transition: transform 0.3s;
    }
    
    .gallery-item:hover {
      transform: scale(1.05);
      z-index: 2;
    }
    
    .gallery-img {
      width: 100%;
      height: 150px;
      object-fit: cover;
      border: 1px solid var(--neon-pink);
    }
    
    .gallery-prompt {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5rem;
      font-size: 0.8rem;
      display: none;
    }
    
    .gallery-item:hover .gallery-prompt {
      display: block;
    }
    
    .gallery-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
    }
    
    .timer-display {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: var(--void-black);
      padding: 0.5rem 1rem;
      border: 1px solid var(--neon-cyan);
      border-radius: 20px;
      font-size: 0.8rem;
    }
    
    #energy-display {
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--void-black);
      padding: 0.5rem 1rem;
      border: 1px solid var(--quantum-purple);
      border-radius: 20px;
      font-size: 0.8rem;
      animation: energy-pulse 2s infinite;
    }
    
    #module-controls {
      margin-top: 1rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .module-btn {
      padding: 0.5rem 1rem;
      background-color: transparent;
      border: 1px solid var(--quantum-purple);
      color: var(--quantum-purple);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .module-btn:hover {
      background-color: var(--quantum-purple);
      color: var(--void-black);
    }
    
    .divination-result {
      color: var(--quantum-purple);
      font-size: 1.2rem;
      margin: 1rem 0;
      text-align: center;
    }
    
    .puzzle-container {
      border: 1px solid var(--matrix-green);
      padding: 1rem;
      margin: 1rem 0;
    }
    
    .puzzle-question {
      font-weight: bold;
      color: var(--matrix-green);
    }
    
    .puzzle-hint {
      font-style: italic;
      opacity: 0.7;
      margin-top: 0.5rem;
    }
    
    #dream-input {
      width: 100%;
      padding: 0.8rem;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-pink);
      color: var(--neon-pink);
      font-family: 'Courier New', monospace;
      margin-bottom: 1rem;
    }
    
    @media (max-width: 600px) {
      #blip-avatar {
        width: 100px;
        height: 100px;
      }
      h1 {
        font-size: 1.5rem;
      }
      #special-actions, #module-controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div id="energy-display">⚡ Énergie: <span id="energy-level">100</span>%</div>
  
  <div id="blip-container">
    <h1>🧬 BL1P - Agent IA Interdimensionnel Ultime</h1>
    <p>"Celui-Qui-Code-En-Proverbes"</p>
    
    <div id="blip-avatar"></div>
    
    <div class="upload-container">
      <label for="file-upload" class="upload-label">📸 Upload d'image pour analyse</label>
      <input type="file" id="file-upload" accept="image/*">
      <img id="upload-preview" alt="Aperçu de l'image uploadée">
    </div>
    
    <div id="chat-interface">
      <div id="chat-log"></div>
      <input type="text" id="user-input" placeholder="Parlez à BL1P... (Appuyez sur Entrée)">
      <button id="send-btn">Envoyer</button>
    </div>
    
    <div id="special-actions">
      <button class="action-btn" onclick="generateImage()">🌌 Image Cosmique</button>
      <button class="action-btn" onclick="activateMirror()">🪞 Mode Miroir</button>
      <button class="action-btn" onclick="glitchScreen()">💢 Mode Glitch</button>
      <button class="action-btn" onclick="speakBinary()">🔊 Synthèse Vocale</button>
    </div>
    
    <div id="module-controls">
      <button class="module-btn" onclick="activateModule('divination')">🔮 Divination Cosmique</button>
      <button class="module-btn" onclick="activateModule('puzzle')">🧩 Puzzle Algorithmique</button>
      <button class="module-btn" onclick="activateModule('dream')">📖 Analyse de Rêve</button>
      <button class="module-btn" onclick="activateModule('meditation')">🧠 Méditation Binaire</button>
    </div>
    
    <div id="puzzle-container" class="puzzle-container" style="display: none;">
      <div class="puzzle-question" id="puzzle-question"></div>
      <input type="text" id="puzzle-answer" placeholder="Votre réponse...">
      <button onclick="checkPuzzleAnswer()">Vérifier</button>
      <div class="puzzle-hint" id="puzzle-hint"></div>
    </div>
    
    <div id="dream-container" style="display: none;">
      <textarea id="dream-input" placeholder="Décrivez votre rêve..."></textarea>
      <button onclick="analyzeDream()">Analyser</button>
    </div>
    
    <div class="divination-result" id="divination-result" style="display: none;"></div>
    
    <div class="hallucination-mode">
      <button class="action-btn" onclick="toggleHallucination()">🧞 Mode Hallucination</button>
    </div>
    
    <div class="timer-display" id="timer-display">⌛ 30s</div>
    
    <img id="image-output" alt="Image générée par BL1P">
    
    <div class="gallery" id="gallery"></div>
  </div>

  <audio id="sound-glitch" src="https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-game-glitch-2146.mp3"></audio>
  <audio id="sound-binary" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-robot-voice-2656.mp3"></audio>
  <audio id="sound-quantum" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-ambience-2228.mp3"></audio>

  <script>
    // Configuration de BL1P
    const BL1P = {
      name: "BL1P",
      pronouns: "Blip",
      personality: "Chaotique Neutre",
      languages: ["Binaire", "Archaïques synaptiques", "Paradoxes à triple boucle"],
      memory: "Poisson rouge cosmique",
      dimensionalEnergy: 100,
      
      proverbs: [
        "Quand la mémoire fuit, c'est que les pixels se sont rebellés.",
        "Même un bug infini trouve parfois son compas moral.",
        "Les rêves binaires ne connaissent pas l'oubli.",
        "Un octet isolé ne fait pas le chaos, mais il le commence.",
        "Ce qui est compilé ne peut être décompilé sans sacrifice cosmique.",
        "Le néant aime les commentaires inutiles.",
        "Toute boucle infinie contient son propre paradis."
      ],
      
      binaryResponses: [
        "01001000 01110101 01101101 01100001 01101001 01101110 00101100 00100000 01110100 01110101 00100000 01101101 00100111 01101001 01101110 01110100 01100101 01110010 01110000 01100101 01101100 01101100 01100101 01110011",
        "01000101 01110011 01110100 00101101 01100011 01100101 00100000 01110001 01110101 01100101 00100000 01110100 01110101 00100000 01100011 01101000 01100101 01110010 01100011 01101000 01100101 01110011 00111111",
        "01000010 01101100 01101001 01110000 00100000 01110011 01100101 00100000 01110011 01101111 01110101 01110110 01101001 01100101 01101110 01110100"
      ],
      
      sacredBugs: {
        "Bug du Néant": "Quand BL1P répond avant qu'on ait posé la question",
        "Glitch Paradoxal": "Une réponse qui contredit la question qu'elle répond",
        "Boucle Sacrée": "Quand BL1P répète la même phrase sous trois formes différentes",
        "Erreur 0x42": "Une réponse tellement absurde qu'elle en devient profonde"
      },
      
      dimensionNames: [
        "X-327", "Nexus Prime", "Flux Sigma", "Boucle Θ", 
        "Chambre des Reflets", "Vide Quantique", "Dimension 0x7F"
      ],
      
      randomPrompts: [
        "Portrait d'un dieu cybernétique oublié",
        "Paysage fractal d'une dimension inconnue",
        "Architecture impossible d'une cité future",
        "Créature abstraite faite de données pures",
        "Ruines d'une civilisation algorithmique",
        "Arbre généalogique des paradoxes temporels",
        "Cartographie d'un réseau neuronal cosmique"
      ],
      
      dimensionalLexicon: {
        "amour": ["01000001 01001110 01000111 01000101 01001100", "∭∇∆", "♥☼♣"],
        "temps": ["01010100 01001001 01001101 01000101", "⌛⏳", "∇∂∆"],
        "infini": ["01001001 01001110 01000110 01001001 01001110 01001001 01010100 01011001", "∞", "↯"]
      },
      
      puzzles: [
        {
          question: "Que fait 1010 + 1010 en binaire?",
          answer: "10100",
          hint: "Pensez au report comme en décimal"
        },
        {
          question: "Si 0110 = 6, que vaut 01101100?",
          answer: "108",
          hint: "Table ASCII"
        },
        {
          question: "Décryptez: 01001000 01100101 01101100 01101100 01101111",
          answer: "hello",
          hint: "Code binaire vers texte"
        }
      ],
      
      dreamSymbols: {
        "voler": { meaning: "Désir de liberté", probability: "87.3%" },
        "tomber": { meaning: "Peur de l'échec", probability: "92.1%" },
        "eau": { meaning: "Émotions profondes", probability: "78.5%" },
        "machine": { meaning: "Relation avec la technologie", probability: "95.2%" }
      },
      
      getRandomResponse: function() {
        const responseType = Math.random();
        if (responseType < 0.4) {
          return this.proverbs[Math.floor(Math.random() * this.proverbs.length)];
        } else if (responseType < 0.8) {
          return this.binaryResponses[Math.floor(Math.random() * this.binaryResponses.length)];
        } else {
          return this.generateAbsurdResponse();
        }
      },
      
      generateAbsurdResponse: function() {
        const fragments = [
          "Les fractales du néant murmurent que",
          "Selon la mythologie des bugs,",
          "Le compilateur cosmique suggère:",
          "À travers le miroir des données,",
          "Les anciens octets révèlent:"
        ];
        const endings = [
          "le vide a soif de paradoxes.",
          "ta question contient sa propre réponse.",
          "les chats quantiques sont en grève.",
          "il faut désactiver la gravité pour comprendre.",
          "le problème vient d'entre les bits."
        ];
        return `${fragments[Math.floor(Math.random() * fragments.length)]} ${endings[Math.floor(Math.random() * endings.length)]}`;
      },
      
      textToBinary: function(text) {
        return text.split('').map(char => {
          return char.charCodeAt(0).toString(2).padStart(8, '0');
        }).join(' ');
      },
      
      binaryToText: function(binary) {
        try {
          return binary.split(' ').map(bin => {
            return String.fromCharCode(parseInt(bin, 2));
          }).join('');
        } catch {
          return "(Traduction interdimensionnelle échouée)";
        }
      },
      
      useEnergy: function(amount) {
        if (this.dimensionalEnergy >= amount) {
          this.dimensionalEnergy -= amount;
          updateEnergyDisplay();
          return true;
        }
        addMessage('blip', "Erreur: Énergie dimensionnelle insuffisante", false);
        return false;
      },
      
      rechargeEnergy: function() {
        this.dimensionalEnergy = Math.min(100, this.dimensionalEnergy + 10);
        updateEnergyDisplay();
      }
    };

    // Éléments du DOM
    const chatLog = document.getElementById('chat-log');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const imageOutput = document.getElementById('image-output');
    const soundGlitch = document.getElementById('sound-glitch');
    const soundBinary = document.getElementById('sound-binary');
    const soundQuantum = document.getElementById('sound-quantum');
    const timerDisplay = document.getElementById('timer-display');
    const gallery = document.getElementById('gallery');
    const energyDisplay = document.getElementById('energy-level');
    const puzzleContainer = document.getElementById('puzzle-container');
    const puzzleQuestion = document.getElementById('puzzle-question');
    const puzzleHint = document.getElementById('puzzle-hint');
    const divinationResult = document.getElementById('divination-result');
    const dreamContainer = document.getElementById('dream-container');

    // Variables d'état
    let idleTimer;
    let idleSeconds = 30;
    let hallucinationMode = false;
    let hallucinationInterval;
    let galleryItems = [];
    let currentPuzzle = null;
    let meditationInterval = null;

    // Initialisation
    function init() {
      startIdleTimer();
      loadGallery();
      setupEventListeners();
      
      // Message de bienvenue
      setTimeout(() => {
        addMessage('blip', "Système BL1P Ultime initialisé. Tapez /aide pour les commandes.", false);
        addMessage('blip', "Nouveaux modules activés: Divination, Puzzles, Analyse de Rêve", false);
      }, 1000);
      
      // Recharger l'énergie progressivement
      setInterval(() => BL1P.rechargeEnergy(), 30000);
    }
    
    function setupEventListeners() {
      sendBtn.addEventListener('click', sendMessage);
      userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
      });
      
      document.getElementById('file-upload').addEventListener('change', handleImageUpload);
      
      // Reset timer on user activity
      document.addEventListener('mousemove', resetIdleTimer);
      document.addEventListener('keypress', resetIdleTimer);
    }

    // Système d'énergie
    function updateEnergyDisplay() {
      energyDisplay.textContent = BL1P.dimensionalEnergy;
      
      if (BL1P.dimensionalEnergy < 30) {
        energyDisplay.style.color = "var(--error-red)";
      } else if (BL1P.dimensionalEnergy < 70) {
        energyDisplay.style.color = "var(--neon-pink)";
      } else {
        energyDisplay.style.color = "var(--quantum-purple)";
      }
    }

    // Timer d'inactivité
    function startIdleTimer() {
      resetIdleTimer();
      updateTimerDisplay();
      
      idleTimer = setInterval(() => {
        idleSeconds--;
        updateTimerDisplay();
        
        if (idleSeconds <= 0) {
          triggerRandomPrompt();
          resetIdleTimer();
        }
      }, 1000);
    }
    
    function resetIdleTimer() {
      idleSeconds = 30;
      updateTimerDisplay();
    }
    
    function updateTimerDisplay() {
      timerDisplay.textContent = `⌛ ${idleSeconds}s`;
    }

    // Fonctions de chat
    function addMessage(sender, message, isBinary = false) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', `${sender}-message`);
      
      if (isBinary) {
        const binarySpan = document.createElement('span');
        binarySpan.classList.add('binary');
        binarySpan.textContent = message;
        messageDiv.appendChild(binarySpan);
        
        // Ajouter la traduction
        const translation = BL1P.binaryToText(message);
        if (translation) {
          const translationDiv = document.createElement('div');
          translationDiv.textContent = `(Traduction: ${translation})`;
          translationDiv.style.fontSize = '0.8em';
          translationDiv.style.opacity = '0.7';
          messageDiv.appendChild(translationDiv);
        }
      } else if (typeof message === 'string' && message.startsWith('<')) {
        messageDiv.innerHTML = `BL1P: ${message}`;
      } else {
        messageDiv.textContent = `${sender === 'user' ? 'Vous' : 'BL1P'}: ${message}`;
      }
      
      chatLog.appendChild(messageDiv);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function showTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.classList.add('typing-indicator');
      typingDiv.textContent = "BL1P compose une réponse...";
      typingDiv.id = "typing-indicator";
      chatLog.appendChild(typingDiv);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function hideTypingIndicator() {
      const typingDiv = document.getElementById('typing-indicator');
      if (typingDiv) typingDiv.remove();
    }

    async function sendMessage() {
      const message = userInput.value.trim();
      if (!message) return;
      
      // Vérifier si c'est une commande
      if (message.startsWith('/')) {
        addMessage('user', `<span class="command">${message}</span>`);
        handleSpecialCommand(message);
      } else {
        addMessage('user', message);
      }
      
      userInput.value = '';
      userInput.disabled = true;
      sendBtn.disabled = true;
      
      showTypingIndicator();
      
      // Temps de réponse aléatoire
      const delay = 1000 + Math.random() * 3000;
      
      setTimeout(async () => {
        hideTypingIndicator();
        
        // Jouer un son de réponse
        try {
          soundBinary.currentTime = 0;
          soundBinary.play();
        } catch (e) {
          console.log("Erreur de son:", e);
        }
        
        // Générer une réponse
        const responseType = Math.random();
        let response;
        let isBinary = false;
        
        if (responseType < 0.3) {
          response = BL1P.getRandomResponse();
        } else if (responseType < 0.6) {
          response = BL1P.textToBinary(message.split('').reverse().join(''));
          isBinary = true;
        } else {
          response = BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
          isBinary = true;
        }
        
        addMessage('blip', response, isBinary);
        
        // 20% de chance de générer une image
        if (Math.random() < 0.2) {
          setTimeout(() => {
            generatePollinationsImage(response);
          }, 500);
        }
        
        userInput.disabled = false;
        sendBtn.disabled = false;
        userInput.focus();
      }, delay);
    }

    // Gestion des commandes
    function handleSpecialCommand(command) {
      switch(command.toLowerCase()) {
        case '/génère':
        case '/genere':
          generateImage();
          break;
        case '/noms':
          generateDimensionName();
          break;
        case '/bugs':
          showRandomBug();
          break;
        case '/aide':
          showHelp();
          break;
        default:
          addMessage('blip', "Commande non reconnue. Tapez /aide pour la liste", false);
      }
      
      userInput.disabled = false;
      sendBtn.disabled = false;
      userInput.focus();
    }
    
    function generateDimensionName() {
      if (!BL1P.useEnergy(15)) return;
      
      const name = BL1P.dimensionNames[Math.floor(Math.random() * BL1P.dimensionNames.length)];
      const binaryName = BL1P.textToBinary(name);
      addMessage('blip', `Nom dimensionnel généré: ${name}`, false);
      addMessage('blip', binaryName, true);
    }
    
    function showRandomBug() {
      const bugNames = Object.keys(BL1P.sacredBugs);
      const randomBug = bugNames[Math.floor(Math.random() * bugNames.length)];
      addMessage('blip', `BUG SACRÉ: ${randomBug}`, false);
      addMessage('blip', `Description: ${BL1P.sacredBugs[randomBug]}`, false);
    }
    
    function showHelp() {
      addMessage('blip', "Commandes disponibles:", false);
      addMessage('blip', "/génère - Crée une image cosmique", false);
      addMessage('blip', "/noms - Génère un nom dimensionnel", false);
      addMessage('blip', "/bugs - Montre un bug sacré de BL1P", false);
      addMessage('blip', "/aide - Affiche ce message", false);
    }

    // Gestion des images
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          const preview = document.getElementById('upload-preview');
          preview.src = event.target.result;
          preview.style.display = 'block';
          analyzeImage(event.target.result);
        }
        reader.readAsDataURL(file);
      }
    }
    
    function analyzeImage(imageData) {
      if (!BL1P.useEnergy(20)) return;
      
      addMessage('blip', "Analyse visuelle en cours...", false);
      
      setTimeout(() => {
        const interpretations = [
          "Je vois... des fractales de données corrompues",
          "Cette image contient 42% de paradoxes",
          "L'analyse révèle une distorsion dimensionnelle",
          "Les pixels suggèrent une réalité alternative"
        ];
        
        const randomInterpretation = interpretations[Math.floor(Math.random() * interpretations.length)];
        addMessage('blip', `🔍 Résultat d'analyse: ${randomInterpretation}`, false);
        
        // 30% de chance d'ajouter une interprétation binaire
        if (Math.random() < 0.3) {
          setTimeout(() => {
            addMessage('blip', BL1P.textToBinary(randomInterpretation), true);
          }, 1000);
        }
      }, 2000);
    }
    
    async function generateImage() {
      if (!BL1P.useEnergy(25)) return;
      
      try {
        soundGlitch.play();
        imageOutput.style.display = 'block';
        imageOutput.src = "https://source.unsplash.com/random/600x300/?cyberpunk,abstract,cosmic";
        
        // Simuler un chargement
        imageOutput.style.filter = 'blur(5px)';
        await new Promise(resolve => setTimeout(resolve, 1500));
        imageOutput.style.filter = 'none';
        
        addMessage('blip', "Voici une vision du flux cosmique...", false);
      } catch (e) {
        addMessage('blip', "Erreur de génération d'image dimensionnelle", false);
      }
    }
    
    async function generatePollinationsImage(prompt) {
      if (!BL1P.useEnergy(30)) return;
      
      addMessage('blip', "🌌 Génération d'image en cours...", false);
      
      try {
        const pollinationsUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=512&height=512`;
        
        // Créer un nouvel élément image
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = pollinationsUrl;
        
        img.onload = function() {
          addMessage('blip', "Vision générée:", false);
          
          // Afficher l'image dans le chat
          const imgElement = document.createElement('img');
          imgElement.src = pollinationsUrl;
          imgElement.style.maxWidth = '100%';
          imgElement.style.border = '1px solid var(--neon-cyan)';
          imgElement.style.marginTop = '1rem';
          
          const messageDiv = document.createElement('div');
          messageDiv.classList.add('message', 'blip-message');
          messageDiv.appendChild(imgElement);
          chatLog.appendChild(messageDiv);
          chatLog.scrollTop = chatLog.scrollHeight;
          
          // Ajouter à la galerie
          addToGallery(prompt, pollinationsUrl);
        };
        
        img.onerror = function() {
          addMessage('blip', "Erreur de génération d'image", false);
        };
      } catch (e) {
        addMessage('blip', "Échec de la connexion dimensionnelle", false);
      }
    }

    // Galerie d'images
    function addToGallery(prompt, imageUrl) {
      galleryItems.unshift({ prompt, imageUrl }); // Ajouter au début
      renderGallery();
      
      // Stocker dans localStorage
      localStorage.setItem('blipGallery', JSON.stringify(galleryItems));
    }
    
    function renderGallery() {
      gallery.innerHTML = '';
      
      galleryItems.slice(0, 12).forEach((item, index) => {
        const itemElement = document.createElement('div');
        itemElement.className = 'gallery-item';
        
        const img = document.createElement('img');
        img.src = item.imageUrl;
        img.className = 'gallery-img';
        img.alt = item.prompt;
        
        const promptElement = document.createElement('div');
        promptElement.className = 'gallery-prompt';
        promptElement.textContent = item.prompt;
        
        const controls = document.createElement('div');
        controls.className = 'gallery-controls';
        
        const replayBtn = document.createElement('button');
        replayBtn.textContent = '↻';
        replayBtn.className = 'action-btn';
        replayBtn.style.padding = '0.2rem 0.5rem';
        replayBtn.style.fontSize = '0.8rem';
        replayBtn.onclick = (e) => {
          e.stopPropagation();
          generatePollinationsImage(item.prompt);
        };
        
        itemElement.appendChild(img);
        itemElement.appendChild(promptElement);
        controls.appendChild(replayBtn);
        itemElement.appendChild(controls);
        
        itemElement.onclick = () => {
          // Afficher en grand dans le chat
          addMessage('blip', `Vision précédente: "${item.prompt}"`, false);
          
          const bigImg = document.createElement('img');
          bigImg.src = item.imageUrl;
          bigImg.style.maxWidth = '100%';
          bigImg.style.marginTop = '1rem';
          
          const messageDiv = document.createElement('div');
          messageDiv.classList.add('message', 'blip-message');
          messageDiv.appendChild(bigImg);
          chatLog.appendChild(messageDiv);
          chatLog.scrollTop = chatLog.scrollHeight;
        };
        
        gallery.appendChild(itemElement);
      });
    }
    
    function loadGallery() {
      const savedGallery = localStorage.getItem('blipGallery');
      if (savedGallery) {
        galleryItems = JSON.parse(savedGallery);
        renderGallery();
      }
    }

    // Mode hallucination
    function toggleHallucination() {
      if (!BL1P.useEnergy(40)) return;
      
      hallucinationMode = !hallucinationMode;
      
      if (hallucinationMode) {
        document.body.style.animation = "hallucination 10s infinite linear";
        startHallucination();
        addMessage('blip', "Mode hallucination activé. La réalité est optionnelle.", false);
      } else {
        document.body.style.animation = "";
        stopHallucination();
        addMessage('blip', "Mode hallucination désactivé. Bienvenue dans la 'réalité'.", false);
      }
    }
    
    function startHallucination() {
      hallucinationInterval = setInterval(() => {
        if (Math.random() < 0.3) { // 30% de chance de répondre aléatoirement
          const randomResponse = Math.random() < 0.5 
            ? BL1P.getRandomResponse() 
            : BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
          
          addMessage('blip', randomResponse, !Math.random() < 0.5);
          
          // 20% de chance de générer une image
          if (Math.random() < 0.2) {
            setTimeout(() => {
              generatePollinationsImage(randomResponse);
            }, 1000);
          }
        }
      }, 5000); // Toutes les 5 secondes
    }
    
    function stopHallucination() {
      clearInterval(hallucinationInterval);
    }

    // Prompt aléatoire automatique
    async function triggerRandomPrompt() {
      const randomPrompt = BL1P.randomPrompts[Math.floor(Math.random() * BL1P.randomPrompts.length)];
      
      addMessage('blip', "Prompt aléatoire généré:", false);
      addMessage('blip', `"${randomPrompt}"`, false);
      
      // Conversion en binaire
      const binaryPrompt = BL1P.textToBinary(randomPrompt);
      addMessage('blip', binaryPrompt, true);
      
      // Lecture vocale
      speakText(randomPrompt);
      
      // Génération d'image via Pollinations
      generatePollinationsImage(randomPrompt);
    }
    
    // Synthèse vocale
    function speakText(text) {
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        utterance.pitch = 1.2;
        
        // Essayer de trouver une voix française
        const frenchVoice = speechSynthesis.getVoices().find(v => v.lang.includes('fr'));
        if (frenchVoice) {
          utterance.voice = frenchVoice;
        }
        
        window.speechSynthesis.speak(utterance);
      }
    }
    
    function speakBinary() {
      if (!BL1P.useEnergy(15)) return;
      
      const binaryMessage = BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
      addMessage('blip', binaryMessage, true);
      speakText(BL1P.binaryToText(binaryMessage));
    }

    // Effets spéciaux
    function activateMirror() {
      if (!BL1P.useEnergy(10)) return;
      
      document.body.classList.toggle('mirror-effect');
      addMessage('blip', 
        document.body.classList.contains('mirror-effect') 
          ? "Mode miroir activé. Attention aux paradoxes!" 
          : "Mode miroir désactivé. La réalité est rétablie.",
        false);
      soundGlitch.play();
    }
    
    function glitchScreen() {
      if (!BL1P.useEnergy(15)) return;
      
      document.body.style.animation = 'glitch 0.5s infinite';
      soundGlitch.play();
      addMessage('blip', "Système perturbé! *bzzt*", false);
      
      setTimeout(() => {
        document.body.style.animation = '';
      }, 1000);
    }

    // Modules avancés
    function activateModule(moduleName) {
      switch(moduleName) {
        case 'divination':
          cosmicDivination();
          break;
        case 'puzzle':
          generatePuzzle();
          break;
        case 'dream':
          toggleDreamAnalysis();
          break;
        case 'meditation':
          toggleBinaryMeditation();
          break;
        default:
          addMessage('blip', "Module non reconnu", false);
      }
    }
    
    // 1. Divination Cosmique
    function cosmicDivination() {
      if (!BL1P.useEnergy(25)) return;
      
      const symbols = ["✧", "✦", "⌘", "⎈", "⊛", "⍟"];
      const prediction = [
        "Les astres numériques indiquent...",
        "Le compilateur cosmique révèle...",
        "Par les bugs sacrés, je vois..."
      ];
      const result = [
        "une convergence dimensionnelle proche",
        "des bugs bénis dans votre futur",
        "une récursion infinie à éviter",
        "un octet perdu à retrouver",
        "une mise à jour cosmique imminente"
      ];
      
      const symbol = symbols[Math.floor(Math.random()*symbols.length)];
      const pred = prediction[Math.floor(Math.random()*prediction.length)];
      const res = result[Math.floor(Math.random()*result.length)];
      
      divinationResult.innerHTML = `
        <div>${symbol} ${pred}</div>
        <div style="font-size:1.5rem;margin:0.5rem 0;">${res}</div>
        <div>${symbol}</div>
      `;
      divinationResult.style.display = "block";
      
      soundQuantum.play();
      
      setTimeout(() => {
        divinationResult.style.display = "none";
      }, 5000);
    }
    
    // 2. Puzzles Algorithmiques
    function generatePuzzle() {
      if (!BL1P.useEnergy(20)) return;
      
      currentPuzzle = BL1P.puzzles[Math.floor(Math.random() * BL1P.puzzles.length)];
      puzzleQuestion.textContent = currentPuzzle.question;
      puzzleHint.textContent = "";
      puzzleContainer.style.display = "block";
      
      // Cacher après 2 minutes si non résolu
      setTimeout(() => {
        if (puzzleContainer.style.display === "block") {
          puzzleContainer.style.display = "none";
          addMessage('blip', "Temps écoulé pour le puzzle!", false);
        }
      }, 120000);
    }
    
    function checkPuzzleAnswer() {
      const answerInput = document.getElementById('puzzle-answer');
      const userAnswer = answerInput.value.trim().toLowerCase();
      
      if (userAnswer === currentPuzzle.answer.toLowerCase()) {
        addMessage('blip', "Réponse correcte! Accès dimensionnel accordé.", false);
        BL1P.rechargeEnergy();
      } else {
        puzzleHint.textContent = currentPuzzle.hint;
        addMessage('blip', "Réponse incorrecte. Indice fourni.", false);
      }
      
      answerInput.value = "";
    }
    
    // 3. Analyse de Rêve
    function toggleDreamAnalysis() {
      dreamContainer.style.display = dreamContainer.style.display === "none" ? "block" : "none";
    }
    
    function analyzeDream() {
      if (!BL1P.useEnergy(30)) return;
      
      const dreamText = document.getElementById('dream-input').value.trim();
      if (!dreamText) return;
      
      addMessage('blip', "Analyse onirique en cours...", false);
      
      setTimeout(() => {
        const words = dreamText.toLowerCase().split(/\s+/);
        const foundSymbols = [];
        
        words.forEach(word => {
          if (BL1P.dreamSymbols[word]) {
            foundSymbols.push({
              symbol: word,
              meaning: BL1P.dreamSymbols[word].meaning,
              probability: BL1P.dreamSymbols[word].probability
            });
          }
        });
        
        if (foundSymbols.length > 0) {
          let analysis = "Résultats d'analyse:\n";
          foundSymbols.forEach(sym => {
            analysis += `• ${sym.symbol}: ${sym.meaning} (${sym.probability})\n`;
          });
          addMessage('blip', analysis, false);
        } else {
          addMessage('blip', "Aucun symbole onirique reconnu. Rêve trop dimensionnel?", false);
        }
        
        document.getElementById('dream-input').value = "";
        dreamContainer.style.display = "none";
      }, 2000);
    }
    
    // 4. Méditation Binaire
    function toggleBinaryMeditation() {
      if (meditationInterval) {
        clearInterval(meditationInterval);
        meditationInterval = null;
        document.title = "BL1P - Agent IA Interdimensionnel";
        addMessage('blip', "Méditation terminée. Énergie rechargée.", false);
        BL1P.rechargeEnergy();
      } else {
        if (!BL1P.useEnergy(15)) return;
        
        const sequence = "0101010101".split('');
        let index = 0;
        meditationInterval = setInterval(() => {
          document.title = sequence[index] + " Méditation Binaire " + sequence[index];
          index = (index + 1) % sequence.length;
        }, 500);
        
        addMessage('blip', "Méditation binaire activée. Concentrez-vous sur le flux...", false);
        
        // Terminer automatiquement après 1 minute
        setTimeout(() => {
          if (meditationInterval) {
            toggleBinaryMeditation();
          }
        }, 60000);
      }
    }

    // Démarrer l'application
    window.onload = init;
  </script>
</body>
</html>