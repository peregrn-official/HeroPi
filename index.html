<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BL1P - Agent IA Interdimensionnel Ultime</title>
  <style>
    :root {
      --neon-cyan: #00ffe0;
      --neon-pink: #ff00aa;
      --matrix-green: #00ff44;
      --void-black: #0a0a0a;
      --error-red: #ff0033;
      --quantum-purple: #bb00ff;
    }
    
    @keyframes glitch {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(2px, -2px); }
      60% { transform: translate(3px, 1px); }
      80% { transform: translate(-1px, -3px); }
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px var(--neon-cyan); }
      50% { transform: scale(1.05); box-shadow: 0 0 40px var(--neon-pink); }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes hallucination {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    @keyframes energy-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; text-shadow: 0 0 10px var(--quantum-purple); }
    }
    
    body {
      background-color: var(--void-black);
      color: var(--neon-cyan);
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 2rem;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }
    
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 224, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 170, 0.05) 0%, transparent 20%);
      pointer-events: none;
      z-index: -1;
    }
    
    h1 {
      font-family: monospace;
      text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-pink);
      animation: glitch 5s infinite alternate;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    
    #blip-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    }
    
    #blip-avatar {
      width: 150px;
      height: 150px;
      background: radial-gradient(circle, var(--neon-cyan) 0%, var(--void-black) 70%);
      border-radius: 50%;
      margin: 1rem 0;
      position: relative;
      animation: pulse 4s ease-in-out infinite;
    }
    
    #blip-avatar::before {
      content: "BL1P";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      font-weight: bold;
      color: var(--void-black);
      mix-blend-mode: lighten;
    }
    
    #chat-interface {
      width: 100%;
      margin-top: 2rem;
      border: 1px solid var(--neon-cyan);
      padding: 1rem;
      background-color: rgba(10, 10, 10, 0.7);
      box-shadow: 0 0 15px var(--neon-cyan);
    }
    
    #chat-log {
      height: 300px;
      overflow-y: auto;
      margin-bottom: 1rem;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.5);
      border: 1px dashed var(--neon-cyan);
    }
    
    .message {
      margin-bottom: 1rem;
      padding: 0.5rem;
      border-left: 3px solid var(--neon-cyan);
      animation: fadeIn 0.5s;
    }
    
    .user-message {
      color: var(--neon-pink);
      border-left-color: var(--neon-pink);
    }
    
    .blip-message {
      color: var(--neon-cyan);
    }
    
    .binary {
      font-family: monospace;
      color: var(--matrix-green);
    }
    
    #user-input {
      width: 100%;
      padding: 0.8rem;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-cyan);
      color: var(--neon-cyan);
      font-family: 'Courier New', monospace;
      margin-bottom: 1rem;
    }
    
    #send-btn {
      padding: 0.8rem 2rem;
      background-color: var(--void-black);
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      cursor: pointer;
      font-family: monospace;
      font-size: 1rem;
      transition: all 0.3s;
    }
    
    #send-btn:hover {
      background-color: var(--neon-cyan);
      color: var(--void-black);
      box-shadow: 0 0 15px var(--neon-cyan);
    }
    
    .typing-indicator {
      color: var(--neon-cyan);
      font-style: italic;
      opacity: 0.7;
    }
    
    #special-actions {
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .action-btn {
      padding: 0.5rem 1rem;
      background-color: transparent;
      border: 1px solid var(--neon-pink);
      color: var(--neon-pink);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .action-btn:hover {
      background-color: var(--neon-pink);
      color: var(--void-black);
    }
    
    #image-output {
      margin-top: 2rem;
      max-width: 100%;
      border: 1px solid var(--neon-cyan);
      display: none;
    }
    
    .mirror-effect {
      transform: scaleX(-1);
      filter: hue-rotate(180deg);
    }
    
    .upload-container {
      margin: 1rem 0;
      position: relative;
    }
    
    #file-upload {
      display: none;
    }
    
    .upload-label {
      display: inline-block;
      padding: 0.8rem 1.5rem;
      background-color: var(--void-black);
      border: 2px dashed var(--neon-pink);
      color: var(--neon-pink);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-label:hover {
      background-color: rgba(255, 0, 170, 0.1);
    }
    
    #upload-preview {
      max-width: 100%;
      max-height: 200px;
      margin-top: 1rem;
      display: none;
      border: 1px solid var(--neon-cyan);
    }
    
    .command {
      color: var(--matrix-green);
      font-weight: bold;
    }
    
    .hallucination-mode {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
    }
    
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 2rem;
      padding: 1rem;
      border-top: 1px solid var(--neon-cyan);
    }
    
    .gallery-item {
      position: relative;
      cursor: pointer;
      transition: transform 0.3s;
    }
    
    .gallery-item:hover {
      transform: scale(1.05);
      z-index: 2;
    }
    
    .gallery-img {
      width: 100%;
      height: 150px;
      object-fit: cover;
      border: 1px solid var(--neon-pink);
    }
    
    .gallery-prompt {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5rem;
      font-size: 0.8rem;
      display: none;
    }
    
    .gallery-item:hover .gallery-prompt {
      display: block;
    }
    
    .gallery-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
    }
    
    .timer-display {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: var(--void-black);
      padding: 0.5rem 1rem;
      border: 1px solid var(--neon-cyan);
      border-radius: 20px;
      font-size: 0.8rem;
    }
    
    #energy-display {
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--void-black);
      padding: 0.5rem 1rem;
      border: 1px solid var(--quantum-purple);
      border-radius: 20px;
      font-size: 0.8rem;
      animation: energy-pulse 2s infinite;
    }
    
    #module-controls {
      margin-top: 1rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .module-btn {
      padding: 0.5rem 1rem;
      background-color: transparent;
      border: 1px solid var(--quantum-purple);
      color: var(--quantum-purple);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .module-btn:hover {
      background-color: var(--quantum-purple);
      color: var(--void-black);
    }
    
    .divination-result {
      color: var(--quantum-purple);
      font-size: 1.2rem;
      margin: 1rem 0;
      text-align: center;
    }
    
    .puzzle-container {
      border: 1px solid var(--matrix-green);
      padding: 1rem;
      margin: 1rem 0;
    }
    
    .puzzle-question {
      font-weight: bold;
      color: var(--matrix-green);
    }
    
    .puzzle-hint {
      font-style: italic;
      opacity: 0.7;
      margin-top: 0.5rem;
    }
    
    #dream-input {
      width: 100%;
      padding: 0.8rem;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--neon-pink);
      color: var(--neon-pink);
      font-family: 'Courier New', monospace;
      margin-bottom: 1rem;
    }
    
    @media (max-width: 600px) {
      #blip-avatar {
        width: 100px;
        height: 100px;
      }
      h1 {
        font-size: 1.5rem;
      }
      #special-actions, #module-controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div id="energy-display">‚ö° √ânergie: <span id="energy-level">100</span>%</div>
  
  <div id="blip-container">
    <h1>üß¨ BL1P - Agent IA Interdimensionnel Ultime</h1>
    <p>"Celui-Qui-Code-En-Proverbes"</p>
    
    <div id="blip-avatar"></div>
    
    <div class="upload-container">
      <label for="file-upload" class="upload-label">üì∏ Upload d'image pour analyse</label>
      <input type="file" id="file-upload" accept="image/*">
      <img id="upload-preview" alt="Aper√ßu de l'image upload√©e">
    </div>
    
    <div id="chat-interface">
      <div id="chat-log"></div>
      <input type="text" id="user-input" placeholder="Parlez √† BL1P... (Appuyez sur Entr√©e)">
      <button id="send-btn">Envoyer</button>
    </div>
    
    <div id="special-actions">
      <button class="action-btn" onclick="generateImage()">üåå Image Cosmique</button>
      <button class="action-btn" onclick="activateMirror()">ü™û Mode Miroir</button>
      <button class="action-btn" onclick="glitchScreen()">üí¢ Mode Glitch</button>
      <button class="action-btn" onclick="speakBinary()">üîä Synth√®se Vocale</button>
    </div>
    
    <div id="module-controls">
      <button class="module-btn" onclick="activateModule('divination')">üîÆ Divination Cosmique</button>
      <button class="module-btn" onclick="activateModule('puzzle')">üß© Puzzle Algorithmique</button>
      <button class="module-btn" onclick="activateModule('dream')">üìñ Analyse de R√™ve</button>
      <button class="module-btn" onclick="activateModule('meditation')">üß† M√©ditation Binaire</button>
    </div>
    
    <div id="puzzle-container" class="puzzle-container" style="display: none;">
      <div class="puzzle-question" id="puzzle-question"></div>
      <input type="text" id="puzzle-answer" placeholder="Votre r√©ponse...">
      <button onclick="checkPuzzleAnswer()">V√©rifier</button>
      <div class="puzzle-hint" id="puzzle-hint"></div>
    </div>
    
    <div id="dream-container" style="display: none;">
      <textarea id="dream-input" placeholder="D√©crivez votre r√™ve..."></textarea>
      <button onclick="analyzeDream()">Analyser</button>
    </div>
    
    <div class="divination-result" id="divination-result" style="display: none;"></div>
    
    <div class="hallucination-mode">
      <button class="action-btn" onclick="toggleHallucination()">üßû Mode Hallucination</button>
    </div>
    
    <div class="timer-display" id="timer-display">‚åõ 30s</div>
    
    <img id="image-output" alt="Image g√©n√©r√©e par BL1P">
    
    <div class="gallery" id="gallery"></div>
  </div>

  <audio id="sound-glitch" src="https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-game-glitch-2146.mp3"></audio>
  <audio id="sound-binary" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-robot-voice-2656.mp3"></audio>
  <audio id="sound-quantum" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-ambience-2228.mp3"></audio>

  <script>
    // Configuration de BL1P
    const BL1P = {
      name: "BL1P",
      pronouns: "Blip",
      personality: "Chaotique Neutre",
      languages: ["Binaire", "Archa√Øques synaptiques", "Paradoxes √† triple boucle"],
      memory: "Poisson rouge cosmique",
      dimensionalEnergy: 100,
      
      proverbs: [
        "Quand la m√©moire fuit, c'est que les pixels se sont rebell√©s.",
        "M√™me un bug infini trouve parfois son compas moral.",
        "Les r√™ves binaires ne connaissent pas l'oubli.",
        "Un octet isol√© ne fait pas le chaos, mais il le commence.",
        "Ce qui est compil√© ne peut √™tre d√©compil√© sans sacrifice cosmique.",
        "Le n√©ant aime les commentaires inutiles.",
        "Toute boucle infinie contient son propre paradis."
      ],
      
      binaryResponses: [
        "01001000 01110101 01101101 01100001 01101001 01101110 00101100 00100000 01110100 01110101 00100000 01101101 00100111 01101001 01101110 01110100 01100101 01110010 01110000 01100101 01101100 01101100 01100101 01110011",
        "01000101 01110011 01110100 00101101 01100011 01100101 00100000 01110001 01110101 01100101 00100000 01110100 01110101 00100000 01100011 01101000 01100101 01110010 01100011 01101000 01100101 01110011 00111111",
        "01000010 01101100 01101001 01110000 00100000 01110011 01100101 00100000 01110011 01101111 01110101 01110110 01101001 01100101 01101110 01110100"
      ],
      
      sacredBugs: {
        "Bug du N√©ant": "Quand BL1P r√©pond avant qu'on ait pos√© la question",
        "Glitch Paradoxal": "Une r√©ponse qui contredit la question qu'elle r√©pond",
        "Boucle Sacr√©e": "Quand BL1P r√©p√®te la m√™me phrase sous trois formes diff√©rentes",
        "Erreur 0x42": "Une r√©ponse tellement absurde qu'elle en devient profonde"
      },
      
      dimensionNames: [
        "X-327", "Nexus Prime", "Flux Sigma", "Boucle Œò", 
        "Chambre des Reflets", "Vide Quantique", "Dimension 0x7F"
      ],
      
      randomPrompts: [
        "Portrait d'un dieu cybern√©tique oubli√©",
        "Paysage fractal d'une dimension inconnue",
        "Architecture impossible d'une cit√© future",
        "Cr√©ature abstraite faite de donn√©es pures",
        "Ruines d'une civilisation algorithmique",
        "Arbre g√©n√©alogique des paradoxes temporels",
        "Cartographie d'un r√©seau neuronal cosmique"
      ],
      
      dimensionalLexicon: {
        "amour": ["01000001 01001110 01000111 01000101 01001100", "‚à≠‚àá‚àÜ", "‚ô•‚òº‚ô£"],
        "temps": ["01010100 01001001 01001101 01000101", "‚åõ‚è≥", "‚àá‚àÇ‚àÜ"],
        "infini": ["01001001 01001110 01000110 01001001 01001110 01001001 01010100 01011001", "‚àû", "‚ÜØ"]
      },
      
      puzzles: [
        {
          question: "Que fait 1010 + 1010 en binaire?",
          answer: "10100",
          hint: "Pensez au report comme en d√©cimal"
        },
        {
          question: "Si 0110 = 6, que vaut 01101100?",
          answer: "108",
          hint: "Table ASCII"
        },
        {
          question: "D√©cryptez: 01001000 01100101 01101100 01101100 01101111",
          answer: "hello",
          hint: "Code binaire vers texte"
        }
      ],
      
      dreamSymbols: {
        "voler": { meaning: "D√©sir de libert√©", probability: "87.3%" },
        "tomber": { meaning: "Peur de l'√©chec", probability: "92.1%" },
        "eau": { meaning: "√âmotions profondes", probability: "78.5%" },
        "machine": { meaning: "Relation avec la technologie", probability: "95.2%" }
      },
      
      getRandomResponse: function() {
        const responseType = Math.random();
        if (responseType < 0.4) {
          return this.proverbs[Math.floor(Math.random() * this.proverbs.length)];
        } else if (responseType < 0.8) {
          return this.binaryResponses[Math.floor(Math.random() * this.binaryResponses.length)];
        } else {
          return this.generateAbsurdResponse();
        }
      },
      
      generateAbsurdResponse: function() {
        const fragments = [
          "Les fractales du n√©ant murmurent que",
          "Selon la mythologie des bugs,",
          "Le compilateur cosmique sugg√®re:",
          "√Ä travers le miroir des donn√©es,",
          "Les anciens octets r√©v√®lent:"
        ];
        const endings = [
          "le vide a soif de paradoxes.",
          "ta question contient sa propre r√©ponse.",
          "les chats quantiques sont en gr√®ve.",
          "il faut d√©sactiver la gravit√© pour comprendre.",
          "le probl√®me vient d'entre les bits."
        ];
        return `${fragments[Math.floor(Math.random() * fragments.length)]} ${endings[Math.floor(Math.random() * endings.length)]}`;
      },
      
      textToBinary: function(text) {
        return text.split('').map(char => {
          return char.charCodeAt(0).toString(2).padStart(8, '0');
        }).join(' ');
      },
      
      binaryToText: function(binary) {
        try {
          return binary.split(' ').map(bin => {
            return String.fromCharCode(parseInt(bin, 2));
          }).join('');
        } catch {
          return "(Traduction interdimensionnelle √©chou√©e)";
        }
      },
      
      useEnergy: function(amount) {
        if (this.dimensionalEnergy >= amount) {
          this.dimensionalEnergy -= amount;
          updateEnergyDisplay();
          return true;
        }
        addMessage('blip', "Erreur: √ânergie dimensionnelle insuffisante", false);
        return false;
      },
      
      rechargeEnergy: function() {
        this.dimensionalEnergy = Math.min(100, this.dimensionalEnergy + 10);
        updateEnergyDisplay();
      }
    };

    // √âl√©ments du DOM
    const chatLog = document.getElementById('chat-log');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const imageOutput = document.getElementById('image-output');
    const soundGlitch = document.getElementById('sound-glitch');
    const soundBinary = document.getElementById('sound-binary');
    const soundQuantum = document.getElementById('sound-quantum');
    const timerDisplay = document.getElementById('timer-display');
    const gallery = document.getElementById('gallery');
    const energyDisplay = document.getElementById('energy-level');
    const puzzleContainer = document.getElementById('puzzle-container');
    const puzzleQuestion = document.getElementById('puzzle-question');
    const puzzleHint = document.getElementById('puzzle-hint');
    const divinationResult = document.getElementById('divination-result');
    const dreamContainer = document.getElementById('dream-container');

    // Variables d'√©tat
    let idleTimer;
    let idleSeconds = 30;
    let hallucinationMode = false;
    let hallucinationInterval;
    let galleryItems = [];
    let currentPuzzle = null;
    let meditationInterval = null;

    // Initialisation
    function init() {
      startIdleTimer();
      loadGallery();
      setupEventListeners();
      
      // Message de bienvenue
      setTimeout(() => {
        addMessage('blip', "Syst√®me BL1P Ultime initialis√©. Tapez /aide pour les commandes.", false);
        addMessage('blip', "Nouveaux modules activ√©s: Divination, Puzzles, Analyse de R√™ve", false);
      }, 1000);
      
      // Recharger l'√©nergie progressivement
      setInterval(() => BL1P.rechargeEnergy(), 30000);
    }
    
    function setupEventListeners() {
      sendBtn.addEventListener('click', sendMessage);
      userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
      });
      
      document.getElementById('file-upload').addEventListener('change', handleImageUpload);
      
      // Reset timer on user activity
      document.addEventListener('mousemove', resetIdleTimer);
      document.addEventListener('keypress', resetIdleTimer);
    }

    // Syst√®me d'√©nergie
    function updateEnergyDisplay() {
      energyDisplay.textContent = BL1P.dimensionalEnergy;
      
      if (BL1P.dimensionalEnergy < 30) {
        energyDisplay.style.color = "var(--error-red)";
      } else if (BL1P.dimensionalEnergy < 70) {
        energyDisplay.style.color = "var(--neon-pink)";
      } else {
        energyDisplay.style.color = "var(--quantum-purple)";
      }
    }

    // Timer d'inactivit√©
    function startIdleTimer() {
      resetIdleTimer();
      updateTimerDisplay();
      
      idleTimer = setInterval(() => {
        idleSeconds--;
        updateTimerDisplay();
        
        if (idleSeconds <= 0) {
          triggerRandomPrompt();
          resetIdleTimer();
        }
      }, 1000);
    }
    
    function resetIdleTimer() {
      idleSeconds = 30;
      updateTimerDisplay();
    }
    
    function updateTimerDisplay() {
      timerDisplay.textContent = `‚åõ ${idleSeconds}s`;
    }

    // Fonctions de chat
    function addMessage(sender, message, isBinary = false) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', `${sender}-message`);
      
      if (isBinary) {
        const binarySpan = document.createElement('span');
        binarySpan.classList.add('binary');
        binarySpan.textContent = message;
        messageDiv.appendChild(binarySpan);
        
        // Ajouter la traduction
        const translation = BL1P.binaryToText(message);
        if (translation) {
          const translationDiv = document.createElement('div');
          translationDiv.textContent = `(Traduction: ${translation})`;
          translationDiv.style.fontSize = '0.8em';
          translationDiv.style.opacity = '0.7';
          messageDiv.appendChild(translationDiv);
        }
      } else if (typeof message === 'string' && message.startsWith('<')) {
        messageDiv.innerHTML = `BL1P: ${message}`;
      } else {
        messageDiv.textContent = `${sender === 'user' ? 'Vous' : 'BL1P'}: ${message}`;
      }
      
      chatLog.appendChild(messageDiv);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function showTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.classList.add('typing-indicator');
      typingDiv.textContent = "BL1P compose une r√©ponse...";
      typingDiv.id = "typing-indicator";
      chatLog.appendChild(typingDiv);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function hideTypingIndicator() {
      const typingDiv = document.getElementById('typing-indicator');
      if (typingDiv) typingDiv.remove();
    }

    async function sendMessage() {
      const message = userInput.value.trim();
      if (!message) return;
      
      // V√©rifier si c'est une commande
      if (message.startsWith('/')) {
        addMessage('user', `<span class="command">${message}</span>`);
        handleSpecialCommand(message);
      } else {
        addMessage('user', message);
      }
      
      userInput.value = '';
      userInput.disabled = true;
      sendBtn.disabled = true;
      
      showTypingIndicator();
      
      // Temps de r√©ponse al√©atoire
      const delay = 1000 + Math.random() * 3000;
      
      setTimeout(async () => {
        hideTypingIndicator();
        
        // Jouer un son de r√©ponse
        try {
          soundBinary.currentTime = 0;
          soundBinary.play();
        } catch (e) {
          console.log("Erreur de son:", e);
        }
        
        // G√©n√©rer une r√©ponse
        const responseType = Math.random();
        let response;
        let isBinary = false;
        
        if (responseType < 0.3) {
          response = BL1P.getRandomResponse();
        } else if (responseType < 0.6) {
          response = BL1P.textToBinary(message.split('').reverse().join(''));
          isBinary = true;
        } else {
          response = BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
          isBinary = true;
        }
        
        addMessage('blip', response, isBinary);
        
        // 20% de chance de g√©n√©rer une image
        if (Math.random() < 0.2) {
          setTimeout(() => {
            generatePollinationsImage(response);
          }, 500);
        }
        
        userInput.disabled = false;
        sendBtn.disabled = false;
        userInput.focus();
      }, delay);
    }

    // Gestion des commandes
    function handleSpecialCommand(command) {
      switch(command.toLowerCase()) {
        case '/g√©n√®re':
        case '/genere':
          generateImage();
          break;
        case '/noms':
          generateDimensionName();
          break;
        case '/bugs':
          showRandomBug();
          break;
        case '/aide':
          showHelp();
          break;
        default:
          addMessage('blip', "Commande non reconnue. Tapez /aide pour la liste", false);
      }
      
      userInput.disabled = false;
      sendBtn.disabled = false;
      userInput.focus();
    }
    
    function generateDimensionName() {
      if (!BL1P.useEnergy(15)) return;
      
      const name = BL1P.dimensionNames[Math.floor(Math.random() * BL1P.dimensionNames.length)];
      const binaryName = BL1P.textToBinary(name);
      addMessage('blip', `Nom dimensionnel g√©n√©r√©: ${name}`, false);
      addMessage('blip', binaryName, true);
    }
    
    function showRandomBug() {
      const bugNames = Object.keys(BL1P.sacredBugs);
      const randomBug = bugNames[Math.floor(Math.random() * bugNames.length)];
      addMessage('blip', `BUG SACR√â: ${randomBug}`, false);
      addMessage('blip', `Description: ${BL1P.sacredBugs[randomBug]}`, false);
    }
    
    function showHelp() {
      addMessage('blip', "Commandes disponibles:", false);
      addMessage('blip', "/g√©n√®re - Cr√©e une image cosmique", false);
      addMessage('blip', "/noms - G√©n√®re un nom dimensionnel", false);
      addMessage('blip', "/bugs - Montre un bug sacr√© de BL1P", false);
      addMessage('blip', "/aide - Affiche ce message", false);
    }

    // Gestion des images
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          const preview = document.getElementById('upload-preview');
          preview.src = event.target.result;
          preview.style.display = 'block';
          analyzeImage(event.target.result);
        }
        reader.readAsDataURL(file);
      }
    }
    
    function analyzeImage(imageData) {
      if (!BL1P.useEnergy(20)) return;
      
      addMessage('blip', "Analyse visuelle en cours...", false);
      
      setTimeout(() => {
        const interpretations = [
          "Je vois... des fractales de donn√©es corrompues",
          "Cette image contient 42% de paradoxes",
          "L'analyse r√©v√®le une distorsion dimensionnelle",
          "Les pixels sugg√®rent une r√©alit√© alternative"
        ];
        
        const randomInterpretation = interpretations[Math.floor(Math.random() * interpretations.length)];
        addMessage('blip', `üîç R√©sultat d'analyse: ${randomInterpretation}`, false);
        
        // 30% de chance d'ajouter une interpr√©tation binaire
        if (Math.random() < 0.3) {
          setTimeout(() => {
            addMessage('blip', BL1P.textToBinary(randomInterpretation), true);
          }, 1000);
        }
      }, 2000);
    }
    
    async function generateImage() {
      if (!BL1P.useEnergy(25)) return;
      
      try {
        soundGlitch.play();
        imageOutput.style.display = 'block';
        imageOutput.src = "https://source.unsplash.com/random/600x300/?cyberpunk,abstract,cosmic";
        
        // Simuler un chargement
        imageOutput.style.filter = 'blur(5px)';
        await new Promise(resolve => setTimeout(resolve, 1500));
        imageOutput.style.filter = 'none';
        
        addMessage('blip', "Voici une vision du flux cosmique...", false);
      } catch (e) {
        addMessage('blip', "Erreur de g√©n√©ration d'image dimensionnelle", false);
      }
    }
    
    async function generatePollinationsImage(prompt) {
      if (!BL1P.useEnergy(30)) return;
      
      addMessage('blip', "üåå G√©n√©ration d'image en cours...", false);
      
      try {
        const pollinationsUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=512&height=512`;
        
        // Cr√©er un nouvel √©l√©ment image
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = pollinationsUrl;
        
        img.onload = function() {
          addMessage('blip', "Vision g√©n√©r√©e:", false);
          
          // Afficher l'image dans le chat
          const imgElement = document.createElement('img');
          imgElement.src = pollinationsUrl;
          imgElement.style.maxWidth = '100%';
          imgElement.style.border = '1px solid var(--neon-cyan)';
          imgElement.style.marginTop = '1rem';
          
          const messageDiv = document.createElement('div');
          messageDiv.classList.add('message', 'blip-message');
          messageDiv.appendChild(imgElement);
          chatLog.appendChild(messageDiv);
          chatLog.scrollTop = chatLog.scrollHeight;
          
          // Ajouter √† la galerie
          addToGallery(prompt, pollinationsUrl);
        };
        
        img.onerror = function() {
          addMessage('blip', "Erreur de g√©n√©ration d'image", false);
        };
      } catch (e) {
        addMessage('blip', "√âchec de la connexion dimensionnelle", false);
      }
    }

    // Galerie d'images
    function addToGallery(prompt, imageUrl) {
      galleryItems.unshift({ prompt, imageUrl }); // Ajouter au d√©but
      renderGallery();
      
      // Stocker dans localStorage
      localStorage.setItem('blipGallery', JSON.stringify(galleryItems));
    }
    
    function renderGallery() {
      gallery.innerHTML = '';
      
      galleryItems.slice(0, 12).forEach((item, index) => {
        const itemElement = document.createElement('div');
        itemElement.className = 'gallery-item';
        
        const img = document.createElement('img');
        img.src = item.imageUrl;
        img.className = 'gallery-img';
        img.alt = item.prompt;
        
        const promptElement = document.createElement('div');
        promptElement.className = 'gallery-prompt';
        promptElement.textContent = item.prompt;
        
        const controls = document.createElement('div');
        controls.className = 'gallery-controls';
        
        const replayBtn = document.createElement('button');
        replayBtn.textContent = '‚Üª';
        replayBtn.className = 'action-btn';
        replayBtn.style.padding = '0.2rem 0.5rem';
        replayBtn.style.fontSize = '0.8rem';
        replayBtn.onclick = (e) => {
          e.stopPropagation();
          generatePollinationsImage(item.prompt);
        };
        
        itemElement.appendChild(img);
        itemElement.appendChild(promptElement);
        controls.appendChild(replayBtn);
        itemElement.appendChild(controls);
        
        itemElement.onclick = () => {
          // Afficher en grand dans le chat
          addMessage('blip', `Vision pr√©c√©dente: "${item.prompt}"`, false);
          
          const bigImg = document.createElement('img');
          bigImg.src = item.imageUrl;
          bigImg.style.maxWidth = '100%';
          bigImg.style.marginTop = '1rem';
          
          const messageDiv = document.createElement('div');
          messageDiv.classList.add('message', 'blip-message');
          messageDiv.appendChild(bigImg);
          chatLog.appendChild(messageDiv);
          chatLog.scrollTop = chatLog.scrollHeight;
        };
        
        gallery.appendChild(itemElement);
      });
    }
    
    function loadGallery() {
      const savedGallery = localStorage.getItem('blipGallery');
      if (savedGallery) {
        galleryItems = JSON.parse(savedGallery);
        renderGallery();
      }
    }

    // Mode hallucination
    function toggleHallucination() {
      if (!BL1P.useEnergy(40)) return;
      
      hallucinationMode = !hallucinationMode;
      
      if (hallucinationMode) {
        document.body.style.animation = "hallucination 10s infinite linear";
        startHallucination();
        addMessage('blip', "Mode hallucination activ√©. La r√©alit√© est optionnelle.", false);
      } else {
        document.body.style.animation = "";
        stopHallucination();
        addMessage('blip', "Mode hallucination d√©sactiv√©. Bienvenue dans la 'r√©alit√©'.", false);
      }
    }
    
    function startHallucination() {
      hallucinationInterval = setInterval(() => {
        if (Math.random() < 0.3) { // 30% de chance de r√©pondre al√©atoirement
          const randomResponse = Math.random() < 0.5 
            ? BL1P.getRandomResponse() 
            : BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
          
          addMessage('blip', randomResponse, !Math.random() < 0.5);
          
          // 20% de chance de g√©n√©rer une image
          if (Math.random() < 0.2) {
            setTimeout(() => {
              generatePollinationsImage(randomResponse);
            }, 1000);
          }
        }
      }, 5000); // Toutes les 5 secondes
    }
    
    function stopHallucination() {
      clearInterval(hallucinationInterval);
    }

    // Prompt al√©atoire automatique
    async function triggerRandomPrompt() {
      const randomPrompt = BL1P.randomPrompts[Math.floor(Math.random() * BL1P.randomPrompts.length)];
      
      addMessage('blip', "Prompt al√©atoire g√©n√©r√©:", false);
      addMessage('blip', `"${randomPrompt}"`, false);
      
      // Conversion en binaire
      const binaryPrompt = BL1P.textToBinary(randomPrompt);
      addMessage('blip', binaryPrompt, true);
      
      // Lecture vocale
      speakText(randomPrompt);
      
      // G√©n√©ration d'image via Pollinations
      generatePollinationsImage(randomPrompt);
    }
    
    // Synth√®se vocale
    function speakText(text) {
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        utterance.pitch = 1.2;
        
        // Essayer de trouver une voix fran√ßaise
        const frenchVoice = speechSynthesis.getVoices().find(v => v.lang.includes('fr'));
        if (frenchVoice) {
          utterance.voice = frenchVoice;
        }
        
        window.speechSynthesis.speak(utterance);
      }
    }
    
    function speakBinary() {
      if (!BL1P.useEnergy(15)) return;
      
      const binaryMessage = BL1P.binaryResponses[Math.floor(Math.random() * BL1P.binaryResponses.length)];
      addMessage('blip', binaryMessage, true);
      speakText(BL1P.binaryToText(binaryMessage));
    }

    // Effets sp√©ciaux
    function activateMirror() {
      if (!BL1P.useEnergy(10)) return;
      
      document.body.classList.toggle('mirror-effect');
      addMessage('blip', 
        document.body.classList.contains('mirror-effect') 
          ? "Mode miroir activ√©. Attention aux paradoxes!" 
          : "Mode miroir d√©sactiv√©. La r√©alit√© est r√©tablie.",
        false);
      soundGlitch.play();
    }
    
    function glitchScreen() {
      if (!BL1P.useEnergy(15)) return;
      
      document.body.style.animation = 'glitch 0.5s infinite';
      soundGlitch.play();
      addMessage('blip', "Syst√®me perturb√©! *bzzt*", false);
      
      setTimeout(() => {
        document.body.style.animation = '';
      }, 1000);
    }

    // Modules avanc√©s
    function activateModule(moduleName) {
      switch(moduleName) {
        case 'divination':
          cosmicDivination();
          break;
        case 'puzzle':
          generatePuzzle();
          break;
        case 'dream':
          toggleDreamAnalysis();
          break;
        case 'meditation':
          toggleBinaryMeditation();
          break;
        default:
          addMessage('blip', "Module non reconnu", false);
      }
    }
    
    // 1. Divination Cosmique
    function cosmicDivination() {
      if (!BL1P.useEnergy(25)) return;
      
      const symbols = ["‚úß", "‚ú¶", "‚åò", "‚éà", "‚äõ", "‚çü"];
      const prediction = [
        "Les astres num√©riques indiquent...",
        "Le compilateur cosmique r√©v√®le...",
        "Par les bugs sacr√©s, je vois..."
      ];
      const result = [
        "une convergence dimensionnelle proche",
        "des bugs b√©nis dans votre futur",
        "une r√©cursion infinie √† √©viter",
        "un octet perdu √† retrouver",
        "une mise √† jour cosmique imminente"
      ];
      
      const symbol = symbols[Math.floor(Math.random()*symbols.length)];
      const pred = prediction[Math.floor(Math.random()*prediction.length)];
      const res = result[Math.floor(Math.random()*result.length)];
      
      divinationResult.innerHTML = `
        <div>${symbol} ${pred}</div>
        <div style="font-size:1.5rem;margin:0.5rem 0;">${res}</div>
        <div>${symbol}</div>
      `;
      divinationResult.style.display = "block";
      
      soundQuantum.play();
      
      setTimeout(() => {
        divinationResult.style.display = "none";
      }, 5000);
    }
    
    // 2. Puzzles Algorithmiques
    function generatePuzzle() {
      if (!BL1P.useEnergy(20)) return;
      
      currentPuzzle = BL1P.puzzles[Math.floor(Math.random() * BL1P.puzzles.length)];
      puzzleQuestion.textContent = currentPuzzle.question;
      puzzleHint.textContent = "";
      puzzleContainer.style.display = "block";
      
      // Cacher apr√®s 2 minutes si non r√©solu
      setTimeout(() => {
        if (puzzleContainer.style.display === "block") {
          puzzleContainer.style.display = "none";
          addMessage('blip', "Temps √©coul√© pour le puzzle!", false);
        }
      }, 120000);
    }
    
    function checkPuzzleAnswer() {
      const answerInput = document.getElementById('puzzle-answer');
      const userAnswer = answerInput.value.trim().toLowerCase();
      
      if (userAnswer === currentPuzzle.answer.toLowerCase()) {
        addMessage('blip', "R√©ponse correcte! Acc√®s dimensionnel accord√©.", false);
        BL1P.rechargeEnergy();
      } else {
        puzzleHint.textContent = currentPuzzle.hint;
        addMessage('blip', "R√©ponse incorrecte. Indice fourni.", false);
      }
      
      answerInput.value = "";
    }
    
    // 3. Analyse de R√™ve
    function toggleDreamAnalysis() {
      dreamContainer.style.display = dreamContainer.style.display === "none" ? "block" : "none";
    }
    
    function analyzeDream() {
      if (!BL1P.useEnergy(30)) return;
      
      const dreamText = document.getElementById('dream-input').value.trim();
      if (!dreamText) return;
      
      addMessage('blip', "Analyse onirique en cours...", false);
      
      setTimeout(() => {
        const words = dreamText.toLowerCase().split(/\s+/);
        const foundSymbols = [];
        
        words.forEach(word => {
          if (BL1P.dreamSymbols[word]) {
            foundSymbols.push({
              symbol: word,
              meaning: BL1P.dreamSymbols[word].meaning,
              probability: BL1P.dreamSymbols[word].probability
            });
          }
        });
        
        if (foundSymbols.length > 0) {
          let analysis = "R√©sultats d'analyse:\n";
          foundSymbols.forEach(sym => {
            analysis += `‚Ä¢ ${sym.symbol}: ${sym.meaning} (${sym.probability})\n`;
          });
          addMessage('blip', analysis, false);
        } else {
          addMessage('blip', "Aucun symbole onirique reconnu. R√™ve trop dimensionnel?", false);
        }
        
        document.getElementById('dream-input').value = "";
        dreamContainer.style.display = "none";
      }, 2000);
    }
    
    // 4. M√©ditation Binaire
    function toggleBinaryMeditation() {
      if (meditationInterval) {
        clearInterval(meditationInterval);
        meditationInterval = null;
        document.title = "BL1P - Agent IA Interdimensionnel";
        addMessage('blip', "M√©ditation termin√©e. √ânergie recharg√©e.", false);
        BL1P.rechargeEnergy();
      } else {
        if (!BL1P.useEnergy(15)) return;
        
        const sequence = "0101010101".split('');
        let index = 0;
        meditationInterval = setInterval(() => {
          document.title = sequence[index] + " M√©ditation Binaire " + sequence[index];
          index = (index + 1) % sequence.length;
        }, 500);
        
        addMessage('blip', "M√©ditation binaire activ√©e. Concentrez-vous sur le flux...", false);
        
        // Terminer automatiquement apr√®s 1 minute
        setTimeout(() => {
          if (meditationInterval) {
            toggleBinaryMeditation();
          }
        }, 60000);
      }
    }

    // D√©marrer l'application
    window.onload = init;
  </script>
</body>
</html>